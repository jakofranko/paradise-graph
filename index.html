<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<title>Paradise Visualizer</title>
		<script src="paradise.js"></script>
        <script>
            const data = paradise.map((row, index) => {
                const splitRow = row.split(' ');

                let code = splitRow[0]; 
                let name = splitRow[1];
                let attr = [], 
                    program = [], 
                    note = [];

                // If more than one space is found in a row, it starts a new section
                let sectionIndex = 0;
                let lastWord = '';
                for (let i = 2; i < splitRow.length; i++) {
                    const word = splitRow[i];

                    // We found a vessel with a name at the size limit.
                    // This word is the attr    
                    if (i == 2 && word != '') {
                        attr.push(word);
                        lastWord = word;
                        sectionIndex++;
                        console.log('Woah! Big name!', word, index); 
                        continue;
                    }

                    // We found an attr at the size limit
                    if (i == 3 && word != '') {
                        program.push(word);
                        lastWord = word;
                        sectionIndex++;
                        console.log('Woah! Big attr!', word, index); 
                        continue;
                    }

                    // Skip consecutive spaces
                    if (word == '' && lastWord == '') {
                        continue;
                    }

                    // Skip spaces and increment sectionIndex
                    if (word == '') {
                        sectionIndex++;
                        lastWord = word;
                        continue;
                    }

                    if (sectionIndex == 0) {
                        attr.push(word);
                    }

                    if (sectionIndex == 1) {
                        program.push(word);
                    }

                    if (sectionIndex == 2) {
                        note.push(word);
                    }

                    lastWord = word;
                }

                // TODO: handle programs at char limit
                // TODO: handle vessels without attrs, but notes and/or programs

                // If a vessel has a note but no program, the note will have been
                // put in the program space.
                if (note.length  == 0 && program.length > 0) {
                    note = [...program];
                    program = undefined;
                }
                return { code, name, attr, program, note };
            });
        </script>
	</head>
	<body>
		<div id="graph"></div>
		<script type="module">
			import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

            // Take the data parsed in the head and process it
            // The code is a string of numbers, split by the '-' char.
            // code[0] is the vessel attribute numbers: locked, hidden, silent, tunnel (0 for no, 1 for yes)
            // code[1] is the ID of the vessel this vessel is in
            // code[2] is the creator ID
            // code[3] is the timestamp it was created and/or updated
            const links = data.map((d, i) => {
                const code = d.code.split('-');

				// For now, point source to self
                return {
                    source: i,
                    target: Number(code[2])
                }
            });

            // Create a copy of data because this will get mutated
            const nodes = data.map(d => ({...d}));

            // Create simulation
            const simulation = d3.forceSimulation(nodes)
                .force("link", d3.forceLink(links).distance(() => 15))
                .force("charge", d3.forceManyBody())
                .force("x", d3.forceX())
                .force("y", d3.forceY())
                
			// Declare the chart dimensions and margins.
			const container = document.getElementById('graph');
			const width = 1640;
			const height = 800;

            // Specify the color scale.
            const color = d3.scaleOrdinal(d3.schemeCategory10);

            // Create the SVG container.
            const svg = d3.create("svg")
                .attr("width", width)
                .attr("height", height)
				.attr("viewBox", [-width / 2, -height / 2, width, height])
				.attr("style", "max-width: 100%; height: auto;");

            const link = svg.append("g")
              .attr("stroke", "#999")
              .attr("stroke-opacity", 0.6)
              .selectAll("line")
              .data(links)
              .join("line")
              .attr("stroke-width", d => Math.sqrt(d.value));

            const node = svg.append("g")
                .attr("stroke", "#fff")
                .attr("stroke-width", 1.5)
                .selectAll("circle")
                .data(nodes)
                .join("circle")
                .attr("r", 3);

            node.append("title")
                .text(d => `${d.attr} ${d.name}`);

			// Begin simulation
			simulation.on("tick", () => {
				link
					.attr("x1", d => d.source.x)
					.attr("y1", d => d.source.y)
					.attr("x2", d => d.target.x)
					.attr("y2", d => d.target.y);

				node
					.attr("cx", d => d.x)
					.attr("cy", d => d.y);
			  });


            // Append the SVG element.
                document.body.append(svg.node());
        </script>
	</body>
</html>
